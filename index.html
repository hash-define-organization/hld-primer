<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2025-09-05 Fri 01:25 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>High Level Design</title>
<meta name="author" content="Prayag Jain" />
<meta name="generator" content="Org Mode" />
<link rel="stylesheet" type="text/css" href="./theme/css/htmlize.css"/>
<link rel="stylesheet" type="text/css" href="./theme/css/define.css"/>
<script type="text/javascript" src="./theme/lib/js/jquery.min.js"></script>
<script type="text/javascript" src="./theme/lib/js/bootstrap.min.js"></script>
<script type="text/javascript" src="./theme/lib/js/jquery.stickytableheaders.min.js"></script>
<script type="text/javascript" src="./theme/js/define.js"></script>
<link rel="apple-touch-icon" sizes="180x180" href="./assets/favicon/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="./assets/favicon/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="./assets/favicon/favicon-16x16.png">
<link rel="manifest" href="./assets/favicon/site.webmanifest">
<meta name="title" content="High Level Design Primer" />
<meta name="description" content="A quick guide to get you started with high level design by Team Hash Define" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://hash-define-organization.github.io/hld-primer/" />
<meta property="og:title" content="High Level Design Primer" />
<meta property="og:description" content="A quick guide to get you started with high level design by Team Hash Define" />
<meta property="og:image" content="./assets/screenshot.png" />
<meta property="twitter:card" content="summary_large_image" />
<meta property="twitter:url" content="https://hash-define-organization.github.io/hld-primer/" />
<meta property="twitter:title" content="High Level Design Primer" />
<meta property="twitter:description" content="A quick guide to get you started with high level design by Team Hash Define" />
<meta property="twitter:image" content="./assets/screenshot.png" />
<meta itemprop="image" content="./assets/screenshot.png" />
<meta itemprop="name" content="High Level Design Primer" />
<meta itemprop="description" content="A quick guide to get you started with high level design by Team Hash Define" />
<script>
  window.MathJax = {
    tex: {
      ams: {
        multlineWidth: '85%'
      },
      tags: 'ams',
      tagSide: 'right',
      tagIndent: '.8em'
    },
    chtml: {
      scale: 1.0,
      displayAlign: 'center',
      displayIndent: '0em'
    },
    svg: {
      scale: 1.0,
      displayAlign: 'center',
      displayIndent: '0em'
    },
    output: {
      font: 'mathjax-modern',
      displayOverflow: 'overflow'
    }
  };
</script>

<script
  id="MathJax-script"
  async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
</script>
</head>
<body>
<div id="content" class="content">
<h1 class="title">High Level Design</h1>
<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#orgccd6756">1. Introduction</a>
<ul>
<li><a href="#orgb6cc3cd">1.1. High Level Design (HLD)</a></li>
<li><a href="#org91d287d">1.2. Network Protocols</a>
<ul>
<li><a href="#org6e32e00">1.2.1. Application Layer</a></li>
<li><a href="#orgfeba19d">1.2.2. Transport Layer</a></li>
</ul>
</li>
<li><a href="#org6cbe3c6">1.3. CAP Theorem</a>
<ul>
<li><a href="#orgb81dbd3">1.3.1. CA: Consistency and Availability</a></li>
<li><a href="#orgd951c36">1.3.2. CP: Consistency and Partition Tolerance</a></li>
<li><a href="#org54e1647">1.3.3. AP: Availability and Partition Tolerance</a></li>
</ul>
</li>
<li><a href="#org47df8a5">1.4. Components</a>
<ul>
<li><a href="#orgc15c850">1.4.1. Load Balancers</a></li>
<li><a href="#orgc6b6549">1.4.2. Caching</a></li>
<li><a href="#org09770aa">1.4.3. Content Delivery Network (CDN)</a></li>
<li><a href="#orgf82c51f">1.4.4. API Gateways</a></li>
<li><a href="#org8261b11">1.4.5. Key-Value Stores</a></li>
<li><a href="#org678f11e">1.4.6. Rate Limiters</a></li>
<li><a href="#org2a2fbca">1.4.7. Monitoring Systems</a></li>
<li><a href="#orga7b33fe">1.4.8. Messaging Queues</a></li>
<li><a href="#org50649ce">1.4.9. Distributed Unique ID Generator</a></li>
<li><a href="#orgfc2c0d4">1.4.10. Distributed Task Schedulers</a></li>
</ul>
</li>
<li><a href="#orgac618ad">1.5. Some Important Terms</a>
<ul>
<li><a href="#org9a0b526">1.5.1. Throughput</a></li>
<li><a href="#org0038641">1.5.2. Latency</a></li>
<li><a href="#orge2b4042">1.5.3. Availability</a></li>
</ul>
</li>
<li><a href="#org326d3a3">1.6. Scalability</a>
<ul>
<li><a href="#org97d7800">1.6.1. What is scalability?</a></li>
</ul>
</li>
<li><a href="#orgde08301">1.7. Consistent Hashing</a>
<ul>
<li><a href="#org80cfba8">1.7.1. Hashing</a></li>
<li><a href="#org09b7032">1.7.2. Consistent Hashing</a></li>
</ul>
</li>
<li><a href="#orgb98be6e">1.8. Database Sharding</a>
<ul>
<li><a href="#org7412a32">1.8.1. Sharding Methods</a></li>
</ul>
</li>
<li><a href="#org6d2cd47">1.9. Caching</a>
<ul>
<li><a href="#org37ff4c7">1.9.1. Types of Cache</a></li>
</ul>
</li>
<li><a href="#org957e215">1.10. Single Point of Failure</a>
<ul>
<li><a href="#org2c7b9a6">1.10.1. Example</a></li>
</ul>
</li>
<li><a href="#orgc7f32e2">1.11. NoSQL Databases</a>
<ul>
<li><a href="#org1f3cb0a">1.11.1. Advantages</a></li>
<li><a href="#org08db0da">1.11.2. Disadvantages</a></li>
<li><a href="#org6255d4e">1.11.3. When should I use SQL DBs?</a></li>
<li><a href="#orgd15b1fd">1.11.4. When should I use NoSQL DBs?</a></li>
</ul>
</li>
<li><a href="#orgf32bb71">1.12. Reverse Proxies</a></li>
<li><a href="#orgeb5b84f">1.13. Database Replication</a>
<ul>
<li><a href="#orga5e0015">1.13.1. Master-Slave Configuration</a></li>
<li><a href="#org52e9b4b">1.13.2. Master-Master Configuration</a></li>
</ul>
</li>
<li><a href="#orgfc03c39">1.14. Hotspots</a></li>
<li><a href="#orgee1c05a">1.15. Failover Mechanisms</a>
<ul>
<li><a href="#orge938a3a">1.15.1. Active-Passive</a></li>
<li><a href="#orgde2d1e0">1.15.2. Active-Active</a></li>
</ul>
</li>
<li><a href="#org1c097f5">1.16. Heartbeats and Health Checks</a>
<ul>
<li><a href="#orgb878953">1.16.1. Heartbeats</a></li>
<li><a href="#org2ad978b">1.16.2. Health Checks</a></li>
</ul>
</li>
<li><a href="#orge2af93a">1.17. Circuit Breakers and Retries</a>
<ul>
<li><a href="#orga019ff7">1.17.1. Circuit Breakers</a></li>
<li><a href="#org766cc83">1.17.2. Retries</a></li>
</ul>
</li>
<li><a href="#org87c1e5f">1.18. Message Queues and Event Streaming</a>
<ul>
<li><a href="#org589e4e8">1.18.1. Message Queue/Broker</a></li>
<li><a href="#org7f1f4c3">1.18.2. Publisher-Subscriber Pattern (Pub/Sub Pattern)</a></li>
</ul>
</li>
<li><a href="#orge679a14">1.19. Monolith vs Microservices</a>
<ul>
<li><a href="#org1f639ed">1.19.1. Monolith</a></li>
<li><a href="#org4e48730">1.19.2. Microservices</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org1f20730">2. Let's Design!</a>
<ul>
<li><a href="#orga0399d6">2.1. Warm-Up</a>
<ul>
<li><a href="#org8bd2781">2.1.1. URL Shortener Design</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-orgccd6756" class="outline-2">
<h2 id="orgccd6756"><span class="section-number-2">1.</span> Introduction</h2>
<div class="outline-text-2" id="text-1">
</div>
<div id="outline-container-orgb6cc3cd" class="outline-3">
<h3 id="orgb6cc3cd"><span class="section-number-3">1.1.</span> High Level Design (HLD)</h3>
<div class="outline-text-3" id="text-1-1">
<p>
It lays out the overall architecture of a system, which describes how components interact with each other, what services exist, and how data flows among them.
</p>
</div>
</div>
<div id="outline-container-org91d287d" class="outline-3">
<h3 id="org91d287d"><span class="section-number-3">1.2.</span> Network Protocols</h3>
<div class="outline-text-3" id="text-1-2">
<p>
A network protocol defines the rules for the communication between two computers.
</p>
</div>
<div id="outline-container-org6e32e00" class="outline-4">
<h4 id="org6e32e00"><span class="section-number-4">1.2.1.</span> Application Layer</h4>
<div class="outline-text-4" id="text-1-2-1">
</div>
<ol class="org-ol">
<li><a id="orgc2d2104"></a>Client Server Protocols<br />
<div class="outline-text-5" id="text-1-2-1-1">
<p>
There exists a server and multiple clients that connect to these servers.  
The clients send requests to the server and the server sends a response.
</p>
<ul class="org-ul">
<li>HTTP
<ul class="org-ul">
<li>Hyper text transfer protocol.</li>
<li>One connection is created.</li>
</ul></li>
<li>FTP
<ul class="org-ul">
<li>File transfer protocol.</li>
<li>Two connections are created (control connection, data connection).</li>
<li>Control connection is persistent while data connection may disconnect.</li>
</ul></li>
<li>SMTP
<ul class="org-ul">
<li>Simple mail transfer protocol</li>
<li>Used for sending emails</li>
<li>IMAP is used for receiving emails</li>
</ul></li>
<li>Web sockets
Bi-directional; the server can send requests as well.
Mostly used for messaging services.</li>
</ul>
</div>
</li>
<li><a id="org1d499ac"></a>Peer-to-Peer (P2P) Protocols<br />
<div class="outline-text-5" id="text-1-2-1-2">
<p>
The clients and servers, all of them can talk to each other which makes it fast.
</p>
<ul class="org-ul">
<li>WebRTC</li>
</ul>
</div>
</li>
</ol>
</div>
<div id="outline-container-orgfeba19d" class="outline-4">
<h4 id="orgfeba19d"><span class="section-number-4">1.2.2.</span> Transport Layer</h4>
<div class="outline-text-4" id="text-1-2-2">
<p>
These are used to send data over IP networks.
</p>
</div>
<ol class="org-ol">
<li><a id="orgb8906c5"></a>TCP/IP<br />
<div class="outline-text-5" id="text-1-2-2-1">
<ul class="org-ul">
<li>Transmission control protocol</li>
<li>It provides a reliable, connection oriented delivery (handshakes).</li>
<li>The order in which data packets are sent is preserved.</li>
<li>If a data packet is not received, it is requested again.</li>
<li>Latency is higher.</li>
<li>Used for file transfer, web (HTTP/HTTPS), email, SSH</li>
</ul>
</div>
</li>
<li><a id="org0b12f32"></a>UDP<br />
<div class="outline-text-5" id="text-1-2-2-2">
<ul class="org-ul">
<li>User datagram protocol</li>
<li>It is unreliable because there is no re-transmission of lost data packets.</li>
<li>Order is not preserved.</li>
<li>Lower latency</li>
<li>Used for gaming, VoIP, streaming, broadcast</li>
</ul>
</div>
</li>
</ol>
</div>
</div>
<div id="outline-container-org6cbe3c6" class="outline-3">
<h3 id="org6cbe3c6"><span class="section-number-3">1.3.</span> CAP Theorem</h3>
<div class="outline-text-3" id="text-1-3">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">Really fun introduction to cap theorem: <a href="http://ksat.me/a-plain-english-introduction-to-cap-theorem">http://ksat.me/a-plain-english-introduction-to-cap-theorem</a></td>
</tr>
</tbody>
</table>

<p>
This theorem allows us to choose the right database for our application. It states that any database can have just two of these three properties. No database can exhibit all three of these properties simultaneously. So when choosing a db, you have to compromise on one of these properties.
</p>
<ul class="org-ul">
<li>C: Consistency
This is different from the consistency mention in "ACID". Here, it means that in all the nodes of a distributed system, each node has the same, consistent view of the replicated data.
For example, if there are 3 nodes in a distributed database, then all nodes must have the same data. If data is modified in one, it should be reflected in all other nodes.</li>
<li>A: Availability
Every node, must be able to respond in a reasonable amount of time. If a node wants to interact with another node, it should always be able to do so. In other words, every request should get a response (and not an error).</li>
<li>P: Partition Tolerance
Partition tolerance means that the system can continue to operate even if the network has some fault causing problems in communication between two nodes.</li>
</ul>

<p>
In real world distributed systems, you always have to choose between CP and AP.
</p>
</div>
<div id="outline-container-orgb81dbd3" class="outline-4">
<h4 id="orgb81dbd3"><span class="section-number-4">1.3.1.</span> CA: Consistency and Availability</h4>
<div class="outline-text-4" id="text-1-3-1">
<ul class="org-ul">
<li>Impractical in real distributed systems because you really need partition tolerance, as network partitions are unavoidable.</li>
<li>Good for single node dbs on a single machine</li>
</ul>
</div>
</div>
<div id="outline-container-orgd951c36" class="outline-4">
<h4 id="orgd951c36"><span class="section-number-4">1.3.2.</span> CP: Consistency and Partition Tolerance</h4>
<div class="outline-text-4" id="text-1-3-2">
<ul class="org-ul">
<li>System prefers correctness over uptime</li>
<li>The nodes may refuse requests untill consistency is restored.</li>
<li>Examples: HBase, MongoDB</li>
</ul>
</div>
</div>
<div id="outline-container-org54e1647" class="outline-4">
<h4 id="org54e1647"><span class="section-number-4">1.3.3.</span> AP: Availability and Partition Tolerance</h4>
<div class="outline-text-4" id="text-1-3-3">
<ul class="org-ul">
<li>System prefers availability.</li>
<li>Preferred when you don't always need to show the latest data. For example, you don't really need to see the most accurate Instagram follower count. It will eventually be updated so it's fine.</li>
<li>The system is always available.</li>
<li>I really like this one.</li>
<li>Eg: Cassandra, DynamoDB, CouchDB, DNS</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org47df8a5" class="outline-3">
<h3 id="org47df8a5"><span class="section-number-3">1.4.</span> Components</h3>
<div class="outline-text-3" id="text-1-4">
</div>
<div id="outline-container-orgc15c850" class="outline-4">
<h4 id="orgc15c850"><span class="section-number-4">1.4.1.</span> Load Balancers</h4>
<div class="outline-text-4" id="text-1-4-1">
<ul class="org-ul">
<li>A load balancer distributes requests evenly across different servers.</li>
<li>So if there are a lot of requests, a load balancer will send different requests to different servers evenly, so that no server is overloaded.</li>
<li>It may be a networking device or a software application.</li>
<li>If a server fails, the load balancer routes requests to servers in good condition instead.</li>
<li>They enable <b>horizontal scaling</b>.</li>
</ul>
</div>
<ol class="org-ol">
<li><a id="orgf68dedb"></a>Types<br />
<div class="outline-text-5" id="text-1-4-1-1">
<ul class="org-ul">
<li>Hardware LB - Specialized devices</li>
<li>Software LB - Just applications that work as load balancers</li>
<li>Cloud LB - Services you can buy online to balance load (AWS, Google Cloud and Azure provide this)</li>
<li>there are more&#x2026; go search..</li>
</ul>
</div>
</li>
<li><a id="org1a12762"></a>Problems<br />
<div class="outline-text-5" id="text-1-4-1-2">
<ul class="org-ul">
<li>Single point of failure: If the load balancer itself has some issues then..</li>
<li>Maybe expensive</li>
<li>Configuring them is a challenge</li>
</ul>
</div>
</li>
</ol>
</div>
<div id="outline-container-orgc6b6549" class="outline-4">
<h4 id="orgc6b6549"><span class="section-number-4">1.4.2.</span> Caching</h4>
<div class="outline-text-4" id="text-1-4-2">
<ul class="org-ul">
<li>A technique for temporarily storing frequently requested data for quick access.</li>
<li>Sending requests to databases can be slower, so caching some data helps speed up things.</li>
<li>Specialized caching software is used like Redis, which stores this temporary data in RAM which is fast.</li>
</ul>
</div>
</div>
<div id="outline-container-org09770aa" class="outline-4">
<h4 id="org09770aa"><span class="section-number-4">1.4.3.</span> Content Delivery Network (CDN)</h4>
<div class="outline-text-4" id="text-1-4-3">
<ul class="org-ul">
<li>A CDN is a specialized network of <b>servers</b>, which hosts media files like images, videos, audios, webpages, or other stuff.</li>
<li>Whenever a client requests this type of data, the request is handled by a nearby CDN server which has cached copy of this content, instead of the main server.</li>
</ul>
</div>
</div>
<div id="outline-container-orgf82c51f" class="outline-4">
<h4 id="orgf82c51f"><span class="section-number-4">1.4.4.</span> API Gateways</h4>
<div class="outline-text-4" id="text-1-4-4">
<ul class="org-ul">
<li>An API gateway provides an interface for clients to access different services of a backend system.</li>
<li>It has routes which the client can send requests to for different purposes and receive a response.</li>
</ul>
</div>
</div>
<div id="outline-container-org8261b11" class="outline-4">
<h4 id="org8261b11"><span class="section-number-4">1.4.5.</span> Key-Value Stores</h4>
<div class="outline-text-4" id="text-1-4-5">
<ul class="org-ul">
<li>They store values in key-value pairs just like hashmaps do.</li>
<li>If it is a persistent store, the data is saved on disk.</li>
</ul>
</div>
</div>
<div id="outline-container-org678f11e" class="outline-4">
<h4 id="org678f11e"><span class="section-number-4">1.4.6.</span> Rate Limiters</h4>
<div class="outline-text-4" id="text-1-4-6">
<ul class="org-ul">
<li>They restrict the rate at which a system or application responds to requests.</li>
<li>These can help prevent DDoS attacks.</li>
</ul>
</div>
</div>
<div id="outline-container-org2a2fbca" class="outline-4">
<h4 id="org2a2fbca"><span class="section-number-4">1.4.7.</span> Monitoring Systems</h4>
<div class="outline-text-4" id="text-1-4-7">
<ul class="org-ul">
<li>These systems are used to collect and analyze various metrics like performance data.</li>
</ul>
</div>
</div>
<div id="outline-container-orga7b33fe" class="outline-4">
<h4 id="orga7b33fe"><span class="section-number-4">1.4.8.</span> Messaging Queues</h4>
<div class="outline-text-4" id="text-1-4-8">
<ul class="org-ul">
<li>They allow communication between two components of a system using a queue (FIFO).</li>
<li>One service sends a message to the queue and then goes back to doing its work.</li>
<li>The service which needs to act on this message receives it and does the required action.</li>
<li>Both are independent of each other and don't need to interact directly.</li>
</ul>
</div>
</div>
<div id="outline-container-org50649ce" class="outline-4">
<h4 id="org50649ce"><span class="section-number-4">1.4.9.</span> Distributed Unique ID Generator</h4>
<div class="outline-text-4" id="text-1-4-9">
<ul class="org-ul">
<li>They create unique IDs to help identify different components of a distributed system.</li>
</ul>
</div>
</div>
<div id="outline-container-orgfc2c0d4" class="outline-4">
<h4 id="orgfc2c0d4"><span class="section-number-4">1.4.10.</span> Distributed Task Schedulers</h4>
<div class="outline-text-4" id="text-1-4-10">
<ul class="org-ul">
<li>Responsible for scheduling and executing tasks in a distributed system.</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-orgac618ad" class="outline-3">
<h3 id="orgac618ad"><span class="section-number-3">1.5.</span> Some Important Terms</h3>
<div class="outline-text-3" id="text-1-5">
</div>
<div id="outline-container-org9a0b526" class="outline-4">
<h4 id="org9a0b526"><span class="section-number-4">1.5.1.</span> Throughput</h4>
<div class="outline-text-4" id="text-1-5-1">
<ul class="org-ul">
<li>Throughput is defined as the amount of information processed in a certain period of time.</li>
<li>You can think of it like the number of actions performed per unit of time.</li>
<li>Higher throughput is considered better.</li>
<li>Unit is <b>bits per second</b>.</li>
</ul>
</div>
</div>
<div id="outline-container-org0038641" class="outline-4">
<h4 id="org0038641"><span class="section-number-4">1.5.2.</span> Latency</h4>
<div class="outline-text-4" id="text-1-5-2">
<ul class="org-ul">
<li>Amount of time required for a single packet of information to be delivered.</li>
<li>It is measured in milliseconds.</li>
<li>Generally, we aim for high throughput and decent latency.</li>
<li>It mainly depends on -
<ul class="org-ul">
<li>Network delays</li>
<li>Delays due to mathematical calculations</li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-orge2b4042" class="outline-4">
<h4 id="orge2b4042"><span class="section-number-4">1.5.3.</span> Availability</h4>
<div class="outline-text-4" id="text-1-5-3">
<ul class="org-ul">
<li>The amount of time a system is available which is measured as - \(availability = \frac{uptime}{uptime + downtime}\)</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org326d3a3" class="outline-3">
<h3 id="org326d3a3"><span class="section-number-3">1.6.</span> Scalability</h3>
<div class="outline-text-3" id="text-1-6">
</div>
<div id="outline-container-org97d7800" class="outline-4">
<h4 id="org97d7800"><span class="section-number-4">1.6.1.</span> What is scalability?</h4>
<div class="outline-text-4" id="text-1-6-1">
<p>
An application is said to be scalable if it is able to support growth or manage increasing workload without compromising performance. It helps in - 
</p>
<ul class="org-ul">
<li>Ensuring availability</li>
<li>Maintaining cost effectiveness</li>
<li>Increasing performance</li>
<li>Managing growth</li>
</ul>
</div>
<ol class="org-ol">
<li><a id="orgcd2c80f"></a>Vertical Scaling<br />
<div class="outline-text-5" id="text-1-6-1-1">
<ul class="org-ul">
<li>Just buy a better server, or add more power to your server like adding more RAM, better CPU, more storage, etc..</li>
<li>At a certain point, you can no longer benefit from vertical scaling.</li>
</ul>
</div>
</li>
<li><a id="org636ad49"></a>Horizontal Scaling<br />
<div class="outline-text-5" id="text-1-6-1-2">
<ul class="org-ul">
<li>Buy more servers and form a network.</li>
<li>The queries will be distributed among all the servers by a load balancer.</li>
<li>Requests are a little slower but this scales very well, you just have to add more servers.</li>
<li>Data duplication is required to maintain consistency or you just don't have consistency.</li>
</ul>
</div>
</li>
</ol>
</div>
</div>
<div id="outline-container-orgde08301" class="outline-3">
<h3 id="orgde08301"><span class="section-number-3">1.7.</span> Consistent Hashing</h3>
<div class="outline-text-3" id="text-1-7">
<p>
It is a technique commonly used to balance load across servers in a load balancer. It's mainly used to balance load across distributed databases.
</p>
</div>
<div id="outline-container-org80cfba8" class="outline-4">
<h4 id="org80cfba8"><span class="section-number-4">1.7.1.</span> Hashing</h4>
<div class="outline-text-4" id="text-1-7-1">
<ul class="org-ul">
<li>A load balancer could use a hashing function to determine which node to store the data on.</li>
<li>For instance, if you had three databases, then a simple hash function <code>k % 3</code> would determine the target db's index.</li>
<li>For example, for user <code>4</code>, the data would be stored on server <code>4 % 3</code> which is <code>1</code>.</li>
<li>Now if let's say you want to add another database node, you would have to shift ALL the data because the hash function would provide you a different value.</li>
<li>This is problematic and may be very expensive if there is a LOT of data.</li>
</ul>
</div>
</div>
<div id="outline-container-org09b7032" class="outline-4">
<h4 id="org09b7032"><span class="section-number-4">1.7.2.</span> Consistent Hashing</h4>
<div class="outline-text-4" id="text-1-7-2">
<ul class="org-ul">
<li>We imagine that our servers are spread across a clock (1-12).</li>
<li>There are 3 servers at positions 1, 3 and 9.</li>
<li>Let's say our hash function returned <code>8</code>. There's no server at position 8, so moving clockwise, it would reach server 9.</li>
<li>So we can do this for all requests.</li>
<li>Let's say another node is added on position <code>7</code>.</li>
<li>Previously, for hash values 4, 5, 6, 7 and 8, all data was stored in server 9.</li>
<li>But now the values 4, 5, 6, and 7 should correspond to the server at position 7, so we just have to some data present in server 9 to server 7.</li>
<li>We can leave other DBs unchanged, which saved us cost and time.</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-orgb98be6e" class="outline-3">
<h3 id="orgb98be6e"><span class="section-number-3">1.8.</span> Database Sharding</h3>
<div class="outline-text-3" id="text-1-8">
<ul class="org-ul">
<li>Used for horizontal scaling of databases.</li>
<li>A database with a lot of records is split into smaller databases, for example, one DB with 1 million rows could be split into five DBs with 200K rows each.</li>
<li>Each chunk is called a "shard" where each shard has the same database schema as the other shards.</li>
</ul>
</div>
<div id="outline-container-org7412a32" class="outline-4">
<h4 id="org7412a32"><span class="section-number-4">1.8.1.</span> Sharding Methods</h4>
<div class="outline-text-4" id="text-1-8-1">
</div>
<ol class="org-ol">
<li><a id="orgcccc1bb"></a>Key Based Sharding<br />
<div class="outline-text-5" id="text-1-8-1-1">
<ul class="org-ul">
<li>Also known as hash-based sharding.</li>
<li>Primary keys or some unique identifiers are used as input to a hash function which outputs a hash value.</li>
<li>This hash value is used to determine which shard to refer to.</li>
<li>You can use consistent hashing here as well.</li>
</ul>
</div>
</li>
<li><a id="org598e050"></a>Range Based Sharding<br />
<div class="outline-text-5" id="text-1-8-1-2">
<ul class="org-ul">
<li>Also known as horizontal sharding.</li>
<li>Ranges of values are used to determine the target shard.</li>
<li>For example, all users with first letters of their names from A-P will be stored in shard 1, P-Z in shard 2.</li>
</ul>
</div>
</li>
<li><a id="org95a8c82"></a>Vertical Sharding<br />
<div class="outline-text-5" id="text-1-8-1-3">
<ul class="org-ul">
<li>Instead of spliting by rows, we split by columns.</li>
<li>For example, first shard may only store the name column, second shard stores the email column etc..</li>
</ul>
</div>
</li>
</ol>
</div>
</div>
<div id="outline-container-org6d2cd47" class="outline-3">
<h3 id="org6d2cd47"><span class="section-number-3">1.9.</span> Caching</h3>
<div class="outline-text-3" id="text-1-9">
<ul class="org-ul">
<li>Caching is a technique which allows you to answer frequently asked queries faster.</li>
<li>It works by storing responses to frequent queries in memory, so that the server won't have to ping the database again and again.</li>
<li>A cache has limited memory, so you have to choose a <b>cache policy</b> to decide what data to <i>evict</i> from the cache when it's full.</li>
<li>You already know about two simple cache policies: LRU and LFU.</li>
<li>In distributed systems, servers use a distributed cache like Redis which is its own independent component in the system.</li>
<li>Whenever data is requested, the cache is queried first. If data is found (cache hit), it is returned (querying a cache is much faster than querying a DB).</li>
<li>If the requested data does not exist in the cache, it is known as a cache miss.</li>
<li>A bad caching policy can cause a lot of cache misses, which is known as "thrashing".</li>
</ul>
</div>
<div id="outline-container-org37ff4c7" class="outline-4">
<h4 id="org37ff4c7"><span class="section-number-4">1.9.1.</span> Types of Cache</h4>
<div class="outline-text-4" id="text-1-9-1">
</div>
<ol class="org-ol">
<li><a id="org4c72584"></a>Application Server Cache<br />
<div class="outline-text-5" id="text-1-9-1-1">
<p>
The server itself has a small cache. The advantage is that the response is instant. The drawback is that each server node has its own cache, so consistency is harder to maintain and maintaining consistency will slow things down.
<img src="https://media.geeksforgeeks.org/wp-content/uploads/20240212140144/Application-Server-Cache-(1).webp" alt="Application-Server-Cache-(1).webp" />
</p>
</div>
</li>
<li><a id="org6116365"></a>Distributed Cache<br />
<div class="outline-text-5" id="text-1-9-1-2">
<ul class="org-ul">
<li>Consistent hashing is used to determine which cache node has the requested data.</li>
<li>Each server can now independently use the distributed cache system.</li>
</ul>

<div id="orgacb65bb" class="figure">
<p><img src="https://media.geeksforgeeks.org/wp-content/uploads/20240110183539/Distributed-Cache.jpg" alt="Distributed-Cache.jpg" />
</p>
</div>
</div>
</li>
<li><a id="org13034a6"></a>Global Cache<br />
<div class="outline-text-5" id="text-1-9-1-3">
<ul class="org-ul">
<li>There's just ONE global cache which is queried whenever data is requested.</li>
<li>It is the responsibility of the global cache to query the DB in case of a cache miss.</li>
</ul>

<div id="org7b6cdfe" class="figure">
<p><img src="https://media.geeksforgeeks.org/wp-content/uploads/20240110183609/Global-Cache.jpg" alt="Global-Cache.jpg" />
</p>
</div>
</div>
</li>
</ol>
</div>
</div>
<div id="outline-container-org957e215" class="outline-3">
<h3 id="org957e215"><span class="section-number-3">1.10.</span> Single Point of Failure</h3>
<div class="outline-text-3" id="text-1-10">
<ul class="org-ul">
<li>A single point of failure occurs when you have a system where there is one component which fails and due to that, the entire system goes down.</li>
<li>So let's say, you just had one server node and for some reason like a power cut, it crashed. Then, the entire application would stop responding to users.</li>
<li>Single point of failure applies to server nodes, databases, load balancers, or literally anything that is a component of a system.</li>
</ul>
</div>
<div id="outline-container-org2c7b9a6" class="outline-4">
<h4 id="org2c7b9a6"><span class="section-number-4">1.10.1.</span> Example</h4>
<div class="outline-text-4" id="text-1-10-1">
<ul class="org-ul">
<li>Let's say we have a simple system
<img src="https://i.postimg.cc/yW410TVN/image.png" alt="image.png" /></li>
<li>If the server fails, the entire system goes down, this is single point of failure.</li>
<li>To avoid this, we can add multiple server nodes
<img src="https://i.postimg.cc/J4LtD1t5/image.png" alt="image.png" /></li>
<li>But how do the clients know now which server to connect to?</li>
<li>For that, we will add a load balancer.
<img src="https://i.postimg.cc/vmgG2jcm/image.png" alt="image.png" /></li>
<li>The server thing is sorted. Yay! But what if the DB goes down? Just add more&#x2026;
<img src="https://i.postimg.cc/1XJx3cfT/image.png" alt="image.png" />
This is called a master slave configuration. There are other configurations as well (discussed later)</li>
<li>Similarly we have to add multiple load balancers as well so that if one goes down, others can work.
<img src="https://i.postimg.cc/Kjs9W9KZ/image.png" alt="image.png" />
We also had to add a DNS service which allows clients to connect to a load balancer.</li>
<li>You may be wondering what if the DNS service goes down? For that we use multiple DNS service providers. Sorted.</li>
<li>What if the entire application is hosted in Japan and suddenly there's an earthquake? For that, we host our application on different regions.</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-orgc7f32e2" class="outline-3">
<h3 id="orgc7f32e2"><span class="section-number-3">1.11.</span> NoSQL Databases</h3>
<div class="outline-text-3" id="text-1-11">
<ul class="org-ul">
<li>You've studied about SQL databases in DBMS, you know how they require you to model all relationships as tables.</li>
<li>SQL databases require normalization/de-normalization to remain performant, which is an added task.</li>
<li>Many NoSQL databases use a JSON like format, for example, MongoDB.</li>
<li>Many of them are key-value based, graph based etc..</li>
</ul>
</div>
<div id="outline-container-org1f3cb0a" class="outline-4">
<h4 id="org1f3cb0a"><span class="section-number-4">1.11.1.</span> Advantages</h4>
<div class="outline-text-4" id="text-1-11-1">
<ul class="org-ul">
<li>They are horizontally scalable (SQL dbs are vertically scalable).</li>
<li>They are more available.</li>
<li>They have a flexible schema, which you can change easily.</li>
</ul>
</div>
</div>
<div id="outline-container-org08db0da" class="outline-4">
<h4 id="org08db0da"><span class="section-number-4">1.11.2.</span> Disadvantages</h4>
<div class="outline-text-4" id="text-1-11-2">
<ul class="org-ul">
<li>ACID properties are not guaranteed.</li>
<li>Less consistency.</li>
<li>These are not read optimized (SQL DBs are better at reads).</li>
<li>No information about relations between different entities.</li>
<li>Joins are hard.</li>
</ul>
</div>
</div>
<div id="outline-container-org6255d4e" class="outline-4">
<h4 id="org6255d4e"><span class="section-number-4">1.11.3.</span> When should I use SQL DBs?</h4>
<div class="outline-text-4" id="text-1-11-3">
<ul class="org-ul">
<li>When you need strong ACID properties. For example, banking systems (transactions), inventory management, payments etc..</li>
<li>When your data has a fixed, well-defined schema.</li>
<li>When you require complex queries for analytics (SQL is a powerful language!).</li>
<li>When data integrity matters.</li>
<li>When you expect moderate-high read/write consistency.</li>
</ul>
</div>
</div>
<div id="outline-container-orgd15b1fd" class="outline-4">
<h4 id="orgd15b1fd"><span class="section-number-4">1.11.4.</span> When should I use NoSQL DBs?</h4>
<div class="outline-text-4" id="text-1-11-4">
<ul class="org-ul">
<li>When you have flexible, evolving schemas or unstructured data. For example, storing analytics, json documents, etc.</li>
<li>When you need horizontal scaling and partitioning (a lot of horizontally distributed SQL DBs do exist though).</li>
<li>When you need simple queryies.</li>
<li>When you need low latency at massive scale.</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-orgf32bb71" class="outline-3">
<h3 id="orgf32bb71"><span class="section-number-3">1.12.</span> Reverse Proxies</h3>
<div class="outline-text-3" id="text-1-12">
<ul class="org-ul">
<li>It is a middleman which sits between clients and servers.</li>
<li>Its primary purpose is to shield backend servers from the clients. The clients won't know which server their request will go to.</li>
<li>They also perform SSL Termination. You know that in "https", "s" stands for secure. It means that "https" calls are encrypted. Reverse proxies decrypt these calls before sending them to the servers.</li>
<li>They can also perform load balancing. <b>So a load balancer, is just a specific type of reverse proxy</b>.</li>
</ul>

<div id="org8f106d9" class="figure">
<p><img src="https://i.postimg.cc/RhVRgFTn/image.png" alt="image.png" />
</p>
</div>
</div>
</div>
<div id="outline-container-orgeb5b84f" class="outline-3">
<h3 id="orgeb5b84f"><span class="section-number-3">1.13.</span> Database Replication</h3>
<div class="outline-text-3" id="text-1-13">
<ul class="org-ul">
<li>It is a technique which involves copying data from one database to one or more databases to
<ul class="org-ul">
<li>Improve availability (prevent single point of failures)</li>
<li>Read scalability (clients can send read requests to these DBs)</li>
<li>Save a backup</li>
</ul></li>
</ul>
</div>
<div id="outline-container-orga5e0015" class="outline-4">
<h4 id="orga5e0015"><span class="section-number-4">1.13.1.</span> Master-Slave Configuration</h4>
<div class="outline-text-4" id="text-1-13-1">
<ul class="org-ul">
<li>There is a master DB which handles all write requests.</li>
<li>There are multiple slave DBs which handle all read requests.</li>
<li>When data is written to master, it is asynchronously or synchronously copied to the slaves.</li>
<li>Advantage is that it provides easy READ scaling.</li>
<li>Disadvantage is that the master becomes a single point of failure :(</li>
</ul>

<div id="orgd85b694" class="figure">
<p><img src="https://i.postimg.cc/s2MMyZVJ/image.png" alt="image.png" />
</p>
</div>
</div>
</div>
<div id="outline-container-org52e9b4b" class="outline-4">
<h4 id="org52e9b4b"><span class="section-number-4">1.13.2.</span> Master-Master Configuration</h4>
<div class="outline-text-4" id="text-1-13-2">
<ul class="org-ul">
<li>Multiple nodes can accept writes.</li>
<li>Changes are replicated to all other nodes to maintain consistency.</li>
<li>There is no single point of failure -&gt; high availability.</li>
<li>Conflicts may arise as two nodes may write different values to the same record simultaneously.
<ul class="org-ul">
<li>Timestamps may be used to fix this issue. The latest timestamp wins.</li>
</ul></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-orgfc03c39" class="outline-3">
<h3 id="orgfc03c39"><span class="section-number-3">1.14.</span> Hotspots</h3>
<div class="outline-text-3" id="text-1-14">
<ul class="org-ul">
<li>A hotspot occurs when a single node receives a disproportionate amount of traffic when compared to other nodes. It may happen to any kind of component like servers, database nodes, load balancers, etc..</li>
<li>For example
<ul class="org-ul">
<li>Product A is trending and is requested a lot more times than other products in the cache, so the cache becomes a hotspot here.</li>
<li>One server handles most of the requests due to poor load balancing.</li>
<li>Using poor hashing functions causing traffic in one DB node to spike.</li>
</ul></li>
<li>To fix hotspots
<ul class="org-ul">
<li>You may shard/partition even further.</li>
<li>Use better load balancing algorithms.</li>
<li>Rate limiting requests per client can help.</li>
<li>Precompute duplicate data to reduce heavy queries hitting a single table/row.</li>
</ul></li>
</ul>
<p>
<img src="https://i.postimg.cc/k5CtN59N/image.png" alt="image.png" />
A cashier with a long queue can be considered a hotspot. To solve this, you may introduce more cashier counters and ask people to move to those instead.
</p>
</div>
</div>
<div id="outline-container-orgee1c05a" class="outline-3">
<h3 id="orgee1c05a"><span class="section-number-3">1.15.</span> Failover Mechanisms</h3>
<div class="outline-text-3" id="text-1-15">
<ul class="org-ul">
<li>Whenever there is a point of failure, failover mechanisms are used to switch to backup components.</li>
</ul>
</div>
<div id="outline-container-orge938a3a" class="outline-4">
<h4 id="orge938a3a"><span class="section-number-4">1.15.1.</span> Active-Passive</h4>
<div class="outline-text-4" id="text-1-15-1">
<ul class="org-ul">
<li>There is an active component and a passive component.</li>
<li>When the active component goes down, the passive one takes over.</li>
<li>Simpler but passive component is idle most of the time.</li>
</ul>
</div>
</div>
<div id="outline-container-orgde2d1e0" class="outline-4">
<h4 id="orgde2d1e0"><span class="section-number-4">1.15.2.</span> Active-Active</h4>
<div class="outline-text-4" id="text-1-15-2">
<ul class="org-ul">
<li>Multiple nodes are active at once.</li>
<li>If one fails, others continue running without disruption.</li>
<li>For example, multiple servers behind a load balancer.</li>
<li>More efficient use of resources, but harder to maintain consistency.</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org1c097f5" class="outline-3">
<h3 id="org1c097f5"><span class="section-number-3">1.16.</span> Heartbeats and Health Checks</h3>
<div class="outline-text-3" id="text-1-16">
</div>
<div id="outline-container-orgb878953" class="outline-4">
<h4 id="orgb878953"><span class="section-number-4">1.16.1.</span> Heartbeats</h4>
<div class="outline-text-4" id="text-1-16-1">
<ul class="org-ul">
<li>A heartbeat is a signal which indicates if a server node is alive or not.</li>
<li>Each server keeps on sending a signal like "I'm alive".</li>
<li>If there is no heartbeat, the node is considered down. So load balancers remove them from rotation.</li>
</ul>
</div>
</div>
<div id="outline-container-org2ad978b" class="outline-4">
<h4 id="org2ad978b"><span class="section-number-4">1.16.2.</span> Health Checks</h4>
<div class="outline-text-4" id="text-1-16-2">
<ul class="org-ul">
<li>A node periodically pings different servers.</li>
<li>For example, there may be a <code>/health</code> endpoint which may send response <code>200 OK</code> if the server is fine.</li>
<li>In both cases, failure mechanisms are used to take action.</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-orge2af93a" class="outline-3">
<h3 id="orge2af93a"><span class="section-number-3">1.17.</span> Circuit Breakers and Retries</h3>
<div class="outline-text-3" id="text-1-17">
</div>
<div id="outline-container-orga019ff7" class="outline-4">
<h4 id="orga019ff7"><span class="section-number-4">1.17.1.</span> Circuit Breakers</h4>
<div class="outline-text-4" id="text-1-17-1">
<ul class="org-ul">
<li>They protect your system from cascading failures (cascading mean something like a domino effect where one crash causes the next node to crash then the next and so on).</li>
<li>For example, If a payment service is down, your API will stop sending requests to that service until it is healthy again.</li>
</ul>
</div>
</div>
<div id="outline-container-org766cc83" class="outline-4">
<h4 id="org766cc83"><span class="section-number-4">1.17.2.</span> Retries</h4>
<div class="outline-text-4" id="text-1-17-2">
<ul class="org-ul">
<li>When receiving a failed response, clients may retry a few more times.</li>
<li>Exponential backoff may be used. For example, try at 1sec, then 2sec, then 4sec, then 16sec, then 32sec and so on to avoid flooding a struggling service.</li>
<li>It is combined with circuit breakers to prevent infinite retries.</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org87c1e5f" class="outline-3">
<h3 id="org87c1e5f"><span class="section-number-3">1.18.</span> Message Queues and Event Streaming</h3>
<div class="outline-text-3" id="text-1-18">
</div>
<div id="outline-container-org589e4e8" class="outline-4">
<h4 id="org589e4e8"><span class="section-number-4">1.18.1.</span> Message Queue/Broker</h4>
<div class="outline-text-4" id="text-1-18-1">
<ul class="org-ul">
<li>A message queue is a middleware that lets different services communicate asynchronously by passing messages.</li>
<li>So service A does not call service B directly. It passes its message to the message queue. Whenever service B is available, it picks it up.</li>
<li>Service A and B can keep doing their work independently without blocking other clients.</li>
<li>Some examples are Kafka, RabbitMQ, AWS SQS, etc..</li>
</ul>

<div id="org7f21a0c" class="figure">
<p><img src="https://i.postimg.cc/V5PyVpKt/image.png" alt="image.png" />
</p>
</div>
</div>
</div>
<div id="outline-container-org7f1f4c3" class="outline-4">
<h4 id="org7f1f4c3"><span class="section-number-4">1.18.2.</span> Publisher-Subscriber Pattern (Pub/Sub Pattern)</h4>
<div class="outline-text-4" id="text-1-18-2">
<ul class="org-ul">
<li>One publisher broadcasts a message which multiple subscribers can consume.</li>
<li>For example, Service A broadcasts "Order created". Service B (billing) and Service C (inventory), which subscribed to it, will now act on it.</li>
<li>Multiple consumers can react differently on the same event at the same time.</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-orge679a14" class="outline-3">
<h3 id="orge679a14"><span class="section-number-3">1.19.</span> Monolith vs Microservices</h3>
<div class="outline-text-3" id="text-1-19">
</div>
<div id="outline-container-org1f639ed" class="outline-4">
<h4 id="org1f639ed"><span class="section-number-4">1.19.1.</span> Monolith</h4>
<div class="outline-text-4" id="text-1-19-1">
<ul class="org-ul">
<li>This is a server architecture where there is just a single, unified codebase.</li>
<li>All services resides in just one codebase.</li>
<li>There is only one thing to deploy here.</li>
<li>It is simple to build but very hard to scale.</li>
<li>You would have to scale the entire server instead of an individual service.</li>
<li>Tight coupling.</li>
</ul>
</div>
</div>
<div id="outline-container-org4e48730" class="outline-4">
<h4 id="org4e48730"><span class="section-number-4">1.19.2.</span> Microservices</h4>
<div class="outline-text-4" id="text-1-19-2">
<ul class="org-ul">
<li>System is decomposed into multiple small services.</li>
<li>Each service can be scaled individually depending on the requirements.</li>
<li>One service goes down, the rest are unbothered.</li>
<li>Services are loosely coupled.</li>
<li>For inter-service communication, gSRP is preferred over REST APIs.</li>
</ul>
</div>
</div>
</div>
</div>
<div id="outline-container-org1f20730" class="outline-2">
<h2 id="org1f20730"><span class="section-number-2">2.</span> Let's Design!</h2>
<div class="outline-text-2" id="text-2">
<ul class="org-ul">
<li>We'll gradually increase the difficulty here. Let's start with easy problems first.</li>
</ul>
</div>
<div id="outline-container-orga0399d6" class="outline-3">
<h3 id="orga0399d6"><span class="section-number-3">2.1.</span> Warm-Up</h3>
<div class="outline-text-3" id="text-2-1">
</div>
<div id="outline-container-org8bd2781" class="outline-4">
<h4 id="org8bd2781"><span class="section-number-4">2.1.1.</span> URL Shortener Design</h4>
<div class="outline-text-4" id="text-2-1-1">
<blockquote>
<p>
Recommended video: <a href="https://www.youtube.com/watch?v=qSJAvd5Mgio">https://www.youtube.com/watch?v=qSJAvd5Mgio</a>
</p>
</blockquote>
</div>
<ol class="org-ol">
<li><a id="orgc247539"></a>Step 1: Gather Requirements<br />
<div class="outline-text-5" id="text-2-1-1-1">
<ul class="org-ul">
<li>The first step when tackling a system design problem is gathering information.</li>
<li>There are two types of this: functional and non-functional.</li>
</ul>
</div>
<ol class="org-ol">
<li><a id="orgd842fe6"></a>Functional Requirements<br />
<div class="outline-text-6" id="text-2-1-1-1-1">
<ul class="org-ul">
<li>These are the real world or non technical requirements.</li>
</ul>
</div>
</li>
</ol>
</li>
</ol>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: Prayag Jain</p>
<p class="date">Created: 2025-09-05 Fri 01:25</p>
<p class="validation"><a href="https://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
